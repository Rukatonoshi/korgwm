[+]  Поддержка одного, двух и трех экранов. Если х11 представляет их как один общий виртуальный экран (это лучше всего для широких окон) -- умение выделять в нем три группы тэгов в зависимости от текущего положения мыши
[+]  Поддержка определения экранов с помощью расширения RandR
[+]  Поддержка 10 тэгов на каждом физическом экране (win+1..0 для переключения)
[+]  Реализовать переключение тэгов
[+]  Добавить поддержку переключения языков (setxkbmap)
[+]  Умение выбирать предыдущий тэг при переключении на этот же
[+]  Если экран один и окно одно, то не нужно показывать рамку
[+]  Добавить хоткеи для переключения тэгов
[+]  Умение перемещать окно на конкретный экран или на конкретный тэг (win+shift+1..0, win+shift+f1..f3)
[+]  Функция максимизации окна на конкретном тэге конкретного физ. экрана (нажимаешь win+m, у окошка исчезает frame, на заданном тэге исчезает панелька, окно реконфигурируется под размер экрана)
[+]  Умение задать курсор, чтобы не было стандартного х11 крестика (xsetroot)
[+]  Фокус следует за курсором
[+]  Умение перекидывать курсор на заданный экран по хоткею
[+]  Добавить хоткеи для переключения экранов
[+]  Поддержка window urgency
[+]  Добавить обработчик события urgency
[+]  Нужна панелька, на которой будет время, статус wifi, индикатор языка, заголовок текущего окна (по центру), список тэгов с окнами, на которых подсвечены urgent (слева)
[+]  Поддержка xft на панельке, чтобы шрифты были хорошими
[+]  brightness, galculator, volume, media buttons
[+]  Умение какое-то окошко делать floating по хоткею
[+]  Умение запускать приложения по хоткеям
[+]  Умение подбирать открытые окна

[ ]  Поддержка запуска приложений на заданном тэге -- чтобы почтовик сам летел куда нужно
[ ]  Навигация по окнам с помощью vim-like хоткеев (hjkl в рамках физ. экрана)
[ ]  Подумать про отображение статуса wifi, мб трей?
[ ]  Придумать, как удобно управлять и показывать WiFi
[ ]  Умение изменять размеры окошек/тайлов хотя бы если их 2 <= N <= 4 (change Layout weights)
[ ]  Поддержка конфиг файла, в котором можно будет настраивать хоткеи и команды, которые их запускают; а также коды цветов

[ ]  Умение изменять размеры и положение floating окошек с помощью мышки


[ ]  Посмотреть, можно ли в Gtk Pango указать два шрифта
[+]  Прочитать документацию на возможные ивенты
[+]  Понять, что происходит при reparenting
[+]  Продумать алгоритм тайлинга


windows => {
    wid => {
        id => wid,                  # ID of the window
        on_tags => {},              # hash of tags on which this window is shown
        always_on => Bool,          # flag if window is always_on
        floating => Bool,           # flag if window is floating
        urgent => Bool,             # flag if window is floating
        siblings => {},             # hash keys = transient_for windows, values
        transient_for => Int,       # wid of transient_for window, or undef
        (x, y, w, h),               # geometry of window requested in configure (or set to some defaults); used only for floating windows
        (real_x, real_y, real_w, real_h), # real geometry of the window, set and saved by korgwm for internal purposes
    },
}

screens => {
    0 => {
        tags => {
            1 => {
                screen => Ptr,      # reference to screen
                idx => Int,         # position in the @screen->tags
                max_window => xid,  # if defined, hide panel and maximize window
                windows_tiled => [],# list (performance bye-bye) of windows attached to this tag, also affects Panel tag visibility
                windows_float => [],# list of floating windows on the tag
                urgent_windows => {},   # hash of windows with urgency flag
                layout => Ref,      # reference to Layout object, or undef (when there is no tiled windows on tag)
            },
        },
        always_on => [],            # list of windows to show on each tag on the screen, should be float
        prev_tag => Int,            # id of previous tag on this screen for switch rotation
        (x, y, w, h),               # basically, for pointer warp and xsetroot
        focus => Int,               # wid of focused window, or undef; copied to %focus when switching to the screen
    },
}

focus => {
    screen => ScreenId,             # id of focused screen
    window => Int,                  # wid of focused windows
}
